.TH std::conj(std::complex) 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::conj(std::complex) \- std::conj(std::complex)

.SH Synopsis
   Defined in header <complex>
   template< class T >                                          (until
   std::complex<T> conj( const std::complex<T>& z );            C++20)
   template< class T >                                          (since
   constexpr std::complex<T> conj( const                        C++20)
   std::complex<T>& z );
   Additional overloads \fI(since C++11)\fP
   Defined in header <complex>
   std::complex<float>       conj( float f );
                                                                        (until
   std::complex<double>      conj( double f );                          C++20)

   std::complex<long double> conj( long double f );
   constexpr std::complex<float>       conj( float f ); \fB(1)\fP
                                                                        (since
   constexpr std::complex<double>      conj( double f                   C++20)
   );                                                                   (until
                                                            (A)         C++23)
   constexpr std::complex<long double> conj( long
   double f );
   template< class FloatingPoint >                                      (since
   constexpr std::complex<FloatingPoint> conj(                          C++23)
   FloatingPoint f );
   template< class Integer >                                                    (until
   constexpr std::complex<double> conj( Integer i );            (B)             C++20)
   template< class Integer >                                                    (since
   constexpr std::complex<double> conj( Integer i );                            C++20)

   1) Computes the complex conjugate of z by reversing the sign of the imaginary part.

   A,B) Additional overloads are provided for all integer and
   floating-point types, which are treated as complex numbers with zero   \fI(since C++11)\fP
   imaginary component.

.SH Parameters

   z - complex value
   f - floating-point value
   i - integer value

.SH Return value

   1) The complex conjugate of z.
   A) std::complex(f).
   B) std::complex<double>(i).

.SH Notes

   The additional overloads are not required to be provided exactly as (A,B). They only
   need to be sufficient to ensure that for their argument num:

     * If num has a
       standard
       (until C++23) floating-point type T, then std::conj(num) has the same effect as
       std::conj(std::complex<T>(num)).
     * Otherwise, if num has an integer type, then std::conj(num) has the same effect
       as std::conj(std::complex<double>(num)).

.SH Example

   
// Run this code

 #include <complex>
 #include <iostream>
  
 int main()
 {
     std::complex<double> z(1.0, 2.0);
     std::cout << "The conjugate of " << z << " is " << std::conj(z) << '\\n'
               << "Their product is " << z * std::conj(z) << '\\n';
 }

.SH Output:

 The conjugate of (1,2) is (1,-2)
 Their product is (5,0)

.SH See also

   abs(std::complex) returns the magnitude of a complex number
                     \fI(function template)\fP 
   norm              returns the squared magnitude
                     \fI(function template)\fP 
   polar             constructs a complex number from magnitude and phase angle
                     \fI(function template)\fP 
   C documentation for
   conj
