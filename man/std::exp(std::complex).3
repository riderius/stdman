.TH std::exp(std::complex) 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::exp(std::complex) \- std::exp(std::complex)

.SH Synopsis
   Defined in header <complex>
   template< class T >
   std::complex<T> exp( const std::complex<T>& z );

   Compute base-e exponential of z, that is e (Euler's number, 2.7182818) raised to the
   z power.

.SH Parameters

   z - complex value

.SH Return value

   If no errors occur, e raised to the power of z, \\(\\small e^z\\)ez
   , is returned.

   Error handling and special values

   Errors are reported consistent with math_errhandling.

   If the implementation supports IEEE floating-point arithmetic,

     * std::exp(std::conj(z)) == std::conj(std::exp(z))
     * If z is (±0,+0), the result is (1,+0)
     * If z is (x,+∞) (for any finite x), the result is (NaN,NaN) and FE_INVALID is
       raised.
     * If z is (x,NaN) (for any finite x), the result is (NaN,NaN) and FE_INVALID may
       be raised.
     * If z is (+∞,+0), the result is (+∞,+0)
     * If z is (-∞,y) (for any finite y), the result is +0cis(y)
     * If z is (+∞,y) (for any finite nonzero y), the result is +∞cis(y)
     * If z is (-∞,+∞), the result is (±0,±0) (signs are unspecified)
     * If z is (+∞,+∞), the result is (±∞,NaN) and FE_INVALID is raised (the sign of
       the real part is unspecified)
     * If z is (-∞,NaN), the result is (±0,±0) (signs are unspecified)
     * If z is (+∞,NaN), the result is (±∞,NaN) (the sign of the real part is
       unspecified)
     * If z is (NaN,+0), the result is (NaN,+0)
     * If z is (NaN,y) (for any nonzero y), the result is (NaN,NaN) and FE_INVALID may
       be raised
     * If z is (NaN,NaN), the result is (NaN,NaN)

   where \\(\\small{\\rm cis}(y)\\)cis(y) is \\(\\small \\cos(y)+{\\rm i}\\sin(y)\\)cos(y) + i
   sin(y).

.SH Notes

   The complex exponential function \\(\\small e^z\\)ez
   for \\(\\small z = x + {\\rm i}y\\)z = x+iy equals \\(\\small e^x {\\rm cis}(y)\\)ex
   cis(y), or, \\(\\small e^x (\\cos(y)+{\\rm i}\\sin(y))\\)ex
   (cos(y) + i sin(y)).

   The exponential function is an entire function in the complex plane and has no
   branch cuts.

   The following have equivalent results when the real part is 0:

     * std::exp(std::complex<float>(0, theta))
     * std::complex<float>(cosf(theta), sinf(theta))
     * std::polar(1.f, theta)

   In this case exp can be about 4.5x slower. One of the other forms should be used
   instead of calling exp with an argument whose real part is literal 0. There is no
   benefit in trying to avoid exp with a runtime check of z.real() == 0 though.

.SH Example

   
// Run this code

 #include <cmath>
 #include <complex>
 #include <iostream>
  
 int main()
 {
    const double pi = std::acos(-1.0);
    const std::complex<double> i(0.0, 1.0);
  
    std::cout << std::fixed << " exp(i * pi) = " << std::exp(i * pi) << '\\n';
 }

.SH Output:

 exp(i * pi) = (-1.000000,0.000000)

.SH See also

                      complex natural logarithm with the branch cuts along the negative
   log(std::complex)  real axis
                      \fI(function template)\fP 
   exp
   expf               returns e raised to the given power (\\({\\small e^x}\\)e^x)
   expl               \fI(function)\fP 
   \fI(C++11)\fP
   \fI(C++11)\fP
   exp(std::valarray) applies the function std::exp to each element of valarray
                      \fI(function template)\fP 
   polar              constructs a complex number from magnitude and phase angle
                      \fI(function template)\fP 
   C documentation for
   cexp
