.TH std::flat_map::flat_map 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::flat_map::flat_map \- std::flat_map::flat_map

.SH Synopsis
   flat_map()                                                        \fB(1)\fP  (since C++23)
       : flat_map(key_compare()) { }
   template< class Allocator >                                       \fB(2)\fP  (since C++23)
   flat_map( const flat_map&, const Allocator& alloc );
   template< class Allocator >                                       \fB(3)\fP  (since C++23)
   flat_map( flat_map&&, const Allocator& alloc );
   flat_map( key_container_type key_cont, mapped_container_type
   mapped_cont,                                                      \fB(4)\fP  (since C++23)
             const key_compare& comp = key_compare() );
   template< class Allocator >

   flat_map( const key_container_type& key_cont,                     \fB(5)\fP  (since C++23)
             const mapped_container_type& mapped_cont,

             const Allocator& alloc );
   template< class Allocator >

   flat_map( const key_container_type& key_cont,                     \fB(6)\fP  (since C++23)
             const mapped_container_type& mapped_cont,

             const key_compare& comp, const Allocator& alloc );
   flat_map( std::sorted_unique_t, key_container_type key_cont,

             mapped_container_type mapped_cont,                      \fB(7)\fP  (since C++23)

             const key_compare& comp = key_compare() );
   template< class Allocator >

   flat_map( std::sorted_unique_t, const key_container_type&
   key_cont,                                                         \fB(8)\fP  (since C++23)

             const mapped_container_type& mapped_cont, const
   Allocator& alloc );
   template< class Allocator >

   flat_map( std::sorted_unique_t, const key_container_type&
   key_cont,                                                         \fB(9)\fP  (since C++23)
             const mapped_container_type& mapped_cont,

             const key_compare& comp, const Allocator& alloc );
   explicit flat_map( const key_compare& comp )                      \fB(10)\fP (since C++23)
       : c(), compare(comp) { }
   template< class Allocator >                                       \fB(11)\fP (since C++23)
   flat_map( const key_compare& comp, const Allocator& alloc );
   template< class Allocator >                                       \fB(12)\fP (since C++23)
   explicit flat_map( const Allocator& alloc );
   template< class InputIter >

   flat_map( InputIter first, InputIter last,                        \fB(13)\fP (since C++23)
             const key_compare& comp = key_compare() )

       : c(), compare(comp);
   template< class InputIter, class Allocator >

   flat_map( InputIter first, InputIter last,                        \fB(14)\fP (since C++23)

             const key_compare& comp, const Allocator& alloc );
   template< class InputIter, class Allocator >
   flat_map( InputIter first, InputIter last, const Allocator& alloc \fB(15)\fP (since C++23)
   );
   template< container-compatible-range<value_type> R >

   flat_map( std::from_range_t, R&& rg, const key_compare& comp )    \fB(16)\fP (since C++23)

       : flat_map(comp);
   template< container-compatible-range<value_type> R >

   flat_map( std::from_range_t fr, R&& rg )                          \fB(17)\fP (since C++23)

       : flat_map(fr, std::forward<R>(rg), key_compare()) { }
   template< container-compatible-range<value_type> R, class
   Allocator >                                                       \fB(18)\fP (since C++23)
   flat_map( std::from_range_t, R&& rg, const Allocator& alloc );
   template< container-compatible-range<value_type> R, class
   Allocator >
                                                                     \fB(19)\fP (since C++23)
   flat_map( std::from_range_t, R&& rg, const key_compare& comp,

             const Allocator& alloc );
   template< class InputIter >

   flat_map( std::sorted_unique_t s, InputIter first, InputIter
   last,                                                             \fB(20)\fP (since C++23)
             const key_compare& comp = key_compare() )

       : c(), compare(comp);
   template< class InputIter, class Allocator >

   flat_map( std::sorted_unique_t s, InputIter first, InputIter      \fB(21)\fP (since C++23)
   last,

             const key_compare& comp, const Allocator& alloc );
   template< class InputIter, class Allocator >

   flat_map( std::sorted_unique_t s, InputIter first, InputIter      \fB(22)\fP (since C++23)
   last,

             const Allocator& alloc );
   flat_map( std::initializer_list<value_type> init,

             const key_compare& comp = key_compare() )               \fB(23)\fP (since C++23)

       : flat_map(init.begin(), init.end(), comp) { }
   template< class Allocator >

   flat_map( std::initializer_list<value_type> init, const           \fB(24)\fP (since C++23)
   key_compare& comp,

             const Allocator& alloc );
   template< class Allocator >
   flat_map( std::initializer_list<value_type> init, const           \fB(25)\fP (since C++23)
   Allocator& alloc );
   flat_map( std::sorted_unique_t s,
   std::initializer_list<value_type> init,
                                                                     \fB(26)\fP (since C++23)
             const key_compare& comp = key_compare() )

       : flat_map(s, init.begin(), init.end(), comp) { }
   template< class Allocator >

   flat_map( std::sorted_unique_t s,                                 \fB(27)\fP (since C++23)
   std::initializer_list<value_type> init,

             const key_compare& comp, const Allocator& alloc );
   template< class Allocator >

   flat_map( std::sorted_unique_t s,                                 \fB(28)\fP (since C++23)
   std::initializer_list<value_type> init,

             const Allocator& alloc );

   Constructs new container adaptor from a variety of data sources and optionally using
   user supplied comparison function object comp and/or allocator alloc.

   1) A default constructor. Constructs an empty container adaptor.
   2) A copy constructor. Constructs c with the copy of the contents of other.c and
   compare with other.compare. See allocator usage note below.
   3) A move constructor. Constructs the container adaptor with the contents of other
   using move semantics. See allocator usage note below.
   4) First, initializes c.keys with std::move(key_cont), c.values with
   std::move(mapped_cont), and compare with comp. Then sorts the underlying range
   [begin(), end()) with respect to value_comp(). Finally, erases the duplicate
   elements as if by:
   auto zv = views::zip(c.keys, c.values);
   auto it = ranges::unique(zv, key_equiv(compare)).begin();
   auto dist = distance(zv.begin(), it);
   c.keys.erase(c.keys.begin() + dist, c.keys.end());
   c.values.erase(c.values.begin() + dist, c.values.end());.
   5) Same as \fB(4)\fP, equivalent to flat_map(key_cont, mapped_cont);. See allocator usage
   note below.
   6) Same as \fB(4)\fP, equivalent to flat_map(key_cont, mapped_cont, comp);. See allocator
   usage note below.
   7) Initializes c.keys with std::move(key_cont), c.values with
   std::move(mapped_cont), and compare with comp.
   8) Same as \fB(7)\fP, equivalent to flat_map(s, key_cont, mapped_cont);. See allocator
   usage note below.
   9) Same as \fB(7)\fP, equivalent to flat_map(s, key_cont, mapped_cont, comp);. See
   allocator usage note below.
   10) Constructs an empty container adaptor.
   11,12) Constructs an empty container adaptor. See allocator usage note below.
   13) Constructs the container adaptor with the contents of the range [first, last),
   equivalent to insert(first, last);.
   14,15) Same as \fB(13)\fP. See allocator usage note below.
   16) Constructs the container adaptor with the contents of the range rg. First, uses
   \fB(10)\fP as delegating constructor. Then initializes c with the contents of rg as if by
   insert_range(std::forward<R>(rg));.
   17) Same as \fB(16)\fP using it as delegating constructor.
   18,19) Same as \fB(16)\fP. See allocator usage note below.
   20) Constructs the underlying containers with the contents of the range
   [first, last) as if by insert(first, last).
   21,22) Same as \fB(20)\fP. See allocator usage note below.
   23) An initializer-list constructor. Constructs the underlying container with the
   contents of the initializer list init, using \fB(13)\fP as delegating constructor.
   24,25) Same as \fB(23)\fP. See allocator usage note below.
   26) An initializer-list constructor. Constructs the underlying container with the
   contents of the initializer list init, using \fB(20)\fP as delegating constructor.
   27,28) Save as \fB(26)\fP. See allocator usage note below.

   Note for overloads (13-15,20-22): If [first, last) is not a valid range, the
   behavior is undefined.

   Note for overloads (4-6,13-19,23-25): If multiple elements in the range have keys
   that compare equivalent, it is unspecified which element is inserted (pending
   LWG2844).

.SH Parameters

   key_cont    - a container to be used as source to initialize the underlying keys
                 container
   mapped_cont - a container to be used as source to initialize the underlying values
                 container
   other       - another flat_map to be used as source to initialize the elements of
                 the underlying containers with
   alloc       - an allocator to use for all memory allocations of the underlying
                 containers
   comp        - a function object to be used for all comparisons of keys
   first, last - a range to copy the elements from
   init        - an initializer list to initialize the elements of the underlying
                 containers with
                 a container compatible range (that is, an input_range whose elements
   rg          - are convertible to value_type) to be used as source to initialize the
                 underlying containers
   fr          - a disambiguation tag that indicates that the contained member should
                 be range constructed
   s           - a disambiguation tag that indicates that the input sequence is sorted
                 with respect to value_comp() and all its elements are unique
.SH Type requirements
   -
   InputIt must meet the requirements of LegacyInputIterator.
   -
   Compare must meet the requirements of Compare.
   -
   Allocator must meet the requirements of Allocator.

.SH Complexity

   1) Constant.
   2) Linear in size of other.
   3) Same as the corresponding move-constructor of the wrapped container, i.e.
   constant or linear in size of cont.
   4-6) Linear in \\(\\scriptsize N\\)N if cont is sorted with respect to value_comp(),
   otherwise \\(\\scriptsize \\mathcal{O}(N\\cdot\\log{(N)})\\)𝓞(N·log(N)), where
   \\(\\scriptsize N\\)N is the value of key_cont.size() before this call.
   7-9) Same as the corresponding move-constructor of the wrapped container, i.e.
   constant or linear in size of cont.
   10-12) Constant.
   13-15) Linear in \\(\\scriptsize N\\)N if the input range [first, last) is sorted with
   respect to value_comp(), otherwise \\(\\scriptsize
   \\mathcal{O}(N\\cdot\\log{(N)})\\)𝓞(N·log(N)), where \\(\\scriptsize N\\)N is the value of
   key_cont.size() before this call.
   16-19) Linear in \\(\\scriptsize N\\)N if the input range rg is sorted with respect to
   value_comp(), otherwise \\(\\scriptsize \\mathcal{O}(N\\cdot\\log{(N)})\\)𝓞(N·log(N)),
   where \\(\\scriptsize N\\)N is the value of key_cont.size() before this call.
   20-22) Linear in size of [first, last).
   23-25) Linear in \\(\\scriptsize N\\)N if the elements of init are sorted with respect
   to value_comp(), otherwise \\(\\scriptsize \\mathcal{O}(N\\cdot\\log{(N)})\\)𝓞(N·log(N)),
   where \\(\\scriptsize N\\)N is the value of key_cont.size() before this call.
   26-28) Linear in size of init.

.SH Exceptions

   Calls to Allocator::allocate may throw.

.SH Notes

   After container move construction (overload \fB(3)\fP), references, pointers, and
   iterators (other than the end iterator) to other remain valid, but refer to elements
   that are now in *this. The current standard makes this guarantee via the blanket
   statement in [container.reqmts]/67, and a more direct guarantee is under
   consideration via LWG issue 2321.

.SH Example

    This section is incomplete
    Reason: no example

.SH See also

   operator= assigns values to the container adaptor
             \fI(public member function)\fP 

.SH Category:
     * Todo no example
