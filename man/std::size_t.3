.TH std::size_t 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::size_t \- std::size_t

.SH Synopsis
   Defined in header <cstddef>
   Defined in header <cstdio>
   Defined in header <cstdlib>
   Defined in header <cstring>
   Defined in header <ctime>
   Defined in header <cuchar>                  \fI(since C++17)\fP
   Defined in header <cwchar>
   typedef /*implementation-defined*/ size_t;

   std::size_t is the unsigned integer type of the result of the sizeof operator
   as well as the sizeof... operator and the alignof operator
   \fI(since C++11)\fP.

   The bit width of std::size_t is not less than 16. \fI(since C++11)\fP

.SH Notes

   std::size_t can store the maximum size of a theoretically possible object of any
   type (including array). A type whose size cannot be represented by std::size_t is
   ill-formed. On many platforms (an exception is systems with segmented addressing)
   std::size_t can safely store the value of any non-member pointer, in which case it
   is synonymous with std::uintptr_t.

   std::size_t is commonly used for array indexing and loop counting. Programs that use
   other types, such as unsigned int, for array indexing may fail on, e.g. 64-bit
   systems when the index exceeds UINT_MAX or if it relies on 32-bit modular
   arithmetic.

   When indexing C++ containers, such as std::string, std::vector, etc, the appropriate
   type is the member typedef size_type provided by such containers. It is usually
   defined as a synonym for std::size_t.

   It is unspecified whether the declaration of std::size_t is available in any other
   standard library header. An implementation may avoid introducing this name even when
   the standard requires std::size_t to be used.

   The integer literal suffix for std::size_t is any combination of z or  (since C++23)
   Z with u or U (i.e. zu, zU, Zu, ZU, uz, uZ, Uz, or UZ).

.SH Possible implementation

   using size_t = decltype(sizeof\fB(0)\fP); // valid since C++11

.SH Example

   
// Run this code

 #include <array>
 #include <cstddef>
 #include <iostream>
  
 int main()
 {
     std::array<std::size_t, 10> a;
  
     // Example with C++23 size_t literal
     for (auto i = 0uz; i != a.size(); ++i)
         std::cout << (a[i] = i) << ' ';
     std::cout << '\\n';
  
     // Example of decrementing loop
     for (std::size_t i = a.size(); i--;)
         std::cout << a[i] << ' ';
     std::cout << '\\n';
  
     // Note the naive decrementing loop:
     //  for (std::size_t i = a.size() - 1; i >= 0; --i) ...
     // is an infinite loop, because unsigned numbers are always non-negative
 }

.SH Output:

 0 1 2 3 4 5 6 7 8 9
 9 8 7 6 5 4 3 2 1 0

.SH References

     * C++23 standard (ISO/IEC 14882:2023):

     * 6.8.4 Compound types [basic.compound] (p: 79-80)

     * 7.6.2.5 Sizeof [expr.sizeof] (p: 136)

     * 7.6.2.6 Alignof [expr.alignof] (p: 136)

     * 17.2.4 Sizes, alignments, and offsets [support.types.layout] (p: 504-505)
     * C++20 standard (ISO/IEC 14882:2020):

     * 6.8.3 Compound types [basic.compound] (p: 75-76)

     * 7.6.2.5 Sizeof [expr.sizeof] (p: 129-130)

     * 7.6.2.6 Alignof [expr.alignof] (p: 130)

     * 17.2.4 Sizes, alignments, and offsets [support.types.layout] (p: 507-508)
     * C++17 standard (ISO/IEC 14882:2017):

     * 6.9.2 Compound types [basic.compound] (p: 81-82)

     * 8.3.3 Sizeof [expr.sizeof] (p: 121-122)

     * 8.3.6 Alignof [expr.alignof] (p: 129)

     * 21.2.4 Sizes, alignments, and offsets [support.types.layout] (p: 479)
     * C++14 standard (ISO/IEC 14882:2014):

     * 3.9.2 Compound types [basic.compound] (p: 73-74)

     * 5.3.3 Sizeof [expr.sizeof] (p: 109-110)

     * 5.3.6 Alignof [expr.alignof] (p: 116)

     * 18.2 Types [support.types] (p: 443-444)
     * C++11 standard (ISO/IEC 14882:2011):

     * 5.3.3 Sizeof [expr.sizeof] (p: 111)

     * 5.3.6 Alignof [expr.alignof] (p: 116)

     * 18.2 Types [support.types] (p: 454-455)
     * C++03 standard (ISO/IEC 14882:2003):

     * 5.3.3 Sizeof [expr.sizeof] (p: 79)
     * C++98 standard (ISO/IEC 14882:1998):

     * 5.3.3 Sizeof [expr.sizeof] (p: 77)

.SH See also

   ptrdiff_t        signed integer type returned when subtracting two pointers
                    \fI(typedef)\fP 
                    byte offset from the beginning of a standard-layout type to
   offsetof         specified member
                    \fI(function macro)\fP 
                    binary,
   integer literals \fI(since C++14)\fP decimal, octal, or hexadecimal numbers of integer
                    type
   C documentation for
   size_t
