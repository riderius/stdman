.TH deductionguidesforstd::flat_multiset 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
deductionguidesforstd::flat_multiset \- deductionguidesforstd::flat_multiset

.SH Synopsis
   Defined in header <flat_set>
   template< class KeyContainer,

             class Compare = std::less<typename
   KeyContainer::value_type> >                                       \fB(1)\fP  (since C++23)
   flat_multiset( KeyContainer, Compare = Compare() )

       -> flat_multiset<typename KeyContainer::value_type, Compare,
   KeyContainer>;
   template< class KeyContainer, class Allocator >

   flat_multiset( KeyContainer, Allocator )
       -> flat_multiset<typename KeyContainer::value_type,           \fB(2)\fP  (since C++23)

                        std::less<typename
   KeyContainer::value_type>, KeyContainer>;
   template< class KeyContainer, class Compare, class Allocator >

   flat_multiset( KeyContainer, Compare, Allocator )                 \fB(3)\fP  (since C++23)

       -> flat_multiset<typename KeyContainer::value_type, Compare,
   KeyContainer>;
   template< class KeyContainer,

             class Compare = std::less<typename
   KeyContainer::value_type> >
   flat_multiset( std::sorted_equivalent_t, KeyContainer, Compare =  \fB(4)\fP  (since C++23)
   Compare() )

       -> flat_multiset<typename KeyContainer::value_type, Compare,
   KeyContainer>;
   template< class KeyContainer, class Allocator >

   flat_multiset( std::sorted_equivalent_t, KeyContainer, Allocator
   )                                                                 \fB(5)\fP  (since C++23)
       -> flat_multiset<typename KeyContainer::value_type,

                        std::less<typename
   KeyContainer::value_type>, KeyContainer>;
   template< class KeyContainer, class Compare, class Allocator >

   flat_multiset( std::sorted_equivalent_t, KeyContainer, Compare,
   Allocator )                                                       \fB(6)\fP  (since C++23)

       -> flat_multiset<typename KeyContainer::value_type, Compare,
   KeyContainer>;
   template< class InputIter,

             class Compare =
   std::less</*iter-value-type*/<InputIter>> >                       \fB(7)\fP  (since C++23)
   flat_multiset( InputIter, InputIter, Compare = Compare() )

       -> flat_multiset</*iter-value-type*/<InputIter>, Compare>;
   template< class InputIter,

             class Compare =
   std::less</*iter-value-type*/<InputIter>> >                       \fB(8)\fP  (since C++23)
   flat_multiset( std::sorted_equivalent_t, InputIter, InputIter,
   Compare = Compare() )

       -> flat_multiset</*iter-value-type*/<InputIter>, Compare>;
   template< ranges::input_range R,

             class Compare = std::less<ranges::range_value_t<R>>,
             class Allocator =
   std::allocator<ranges::range_value_t<R>> >
   flat_multiset( std::from_range_t, R&&, Compare = Compare(),       \fB(9)\fP  (since C++23)
   Allocator = Allocator() )
       -> flat_multiset<ranges::range_value_t<R>, Compare,
                        std::vector<ranges::range_value_t<R>,

                        /*alloc-rebind*/<Allocator,
   ranges::range_value_t<R>>>>;
   template< ranges::input_range R, class Allocator >

   flat_multiset( std::from_range_t, R&&, Allocator )
       -> flat_multiset<ranges::range_value_t<R>,
   std::less<ranges::range_value_t<R>>,                              \fB(10)\fP (since C++23)
                        std::vector<ranges::range_value_t<R>,

                        /*alloc-rebind*/<Allocator,
   ranges::range_value_t<R>>>>;
   template< class Key, class Compare = std::less<Key> >

   flat_multiset( std::initializer_list<Key>, Compare = Compare() )  \fB(11)\fP (since C++23)

       -> flat_multiset<Key, Compare>;
   template< class Key, class Compare = std::less<Key> >

   flat_multiset( std::sorted_equivalent_t,                          \fB(12)\fP (since C++23)
                  std::initializer_list<Key>, Compare = Compare() )

       -> flat_multiset<Key, Compare>;

   These deduction guides are provided for to allow deduction from:

   1) A container and a comparator.
   2) A container and an allocator.
   3) A container, a comparator and an allocator.
   4) The std::sorted_equivalent_t tag, a container and a comparator.
   5) The std::sorted_equivalent_t tag, a container and an allocator.
   6) The std::sorted_equivalent_t tag, a container, a comparator and an allocator.
   7) An iterator range and a comparator.
   8) The std::sorted_equivalent_t tag, an iterator range and a comparator.
   9) The std::from_range_t tag, an input_range range, a comparator and an allocator.
   10) The std::from_range_t tag, an input_range range and an allocator.
   11) The std::initializer_list and a comparator.
   12) The std::sorted_equivalent_t tag, the std::initializer_list and a comparator.

   These overloads participate in overload resolution only if InputIt satisfies
   LegacyInputIterator, Alloc satisfies Allocator, and Comp does not satisfy Allocator.

   Note: the extent to which the library determines that a type does not satisfy
   LegacyInputIterator is unspecified, except that as a minimum integral types do not
   qualify as input iterators. Likewise, the extent to which it determines that a type
   does not satisfy Allocator is unspecified, except that as a minimum the member type
   Alloc::value_type must exist and the expression
   std::declval<Alloc&>().allocate(std::size_t{}) must be well-formed when treated as
   an unevaluated operand.

.SH Example

    This section is incomplete
    Reason: no example

.SH Category:
     * Todo no example
