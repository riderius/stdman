.TH std::literals::complex_literals::operator""i,operator""if,operator""il 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::literals::complex_literals::operator""i,operator""if,operator""il \- std::literals::complex_literals::operator""i,operator""if,operator""il

.SH Synopsis
   Defined in header <complex>
   constexpr complex<double> operator""i( long double arg );          \fB(1)\fP \fI(since C++14)\fP
   constexpr complex<double> operator""i( unsigned long long arg );
   constexpr complex<float> operator""if( long double arg );          \fB(2)\fP \fI(since C++14)\fP
   constexpr complex<float> operator""if( unsigned long long arg );
   constexpr complex<long double> operator""il( long double arg );
   constexpr complex<long double> operator""il( unsigned long long    \fB(3)\fP \fI(since C++14)\fP
   arg );

   Forms a std::complex literal representing an imaginary number.

   1) Forms a literal std::complex<double> with the real part zero and imaginary part
   arg.
   2) Forms a literal std::complex<float> with the real part zero and imaginary part
   arg.
   3) Forms a literal std::complex<long double> with the real part zero and imaginary
   part arg.

.SH Parameters

   arg - the value of the imaginary number

.SH Return value

   The std::complex literal with the real part zero and imaginary part arg.

.SH Notes

   These operators are declared in the namespace std::literals::complex_literals, where
   both literals and complex_literals are inline namespaces. Access to these operators
   can be gained with either:

     * using namespace std::literals,
     * using namespace std::complex_literals, or
     * using namespace std::literals::complex_literals.

   Even though if is a keyword in C++, it is a ud-suffix of the literal operator of the
   form operator ""if and in the literal expressions such as 1if or 1.0if because it is
   not separated by whitespace and is not a standalone token.

     Feature-test macro    Value    Std                  Feature
   __cpp_lib_complex_udls 201309L \fI(C++14)\fP User-Defined Literals for std::complex

.SH Possible implementation

                                  operator""i
   constexpr std::complex<double> operator""i(unsigned long long d)
   {
       return std::complex<double> {0.0, static_cast<double>(d)};
   }
    
   constexpr std::complex<double> operator""i(long double d)
   {
       return std::complex<double> {0.0, static_cast<double>(d)};
   }
                                 operator""if
   constexpr std::complex<float> operator""if(unsigned long long d)
   {
       return std::complex<float> {0.0f, static_cast<float>(d)};
   }
    
   constexpr std::complex<float> operator""if(long double d)
   {
       return std::complex<float> {0.0f, static_cast<float>(d)};
   }
                                 operator""il
   constexpr std::complex<long double> operator""il(unsigned long long d)
   {
       return std::complex<long double> {0.0L, static_cast<long double>(d)};
   }
    
   constexpr std::complex<long double> operator""il(long double d)
   {
       return std::complex<long double> {0.0L, d};
   }

.SH Example

   
// Run this code

 #include <complex>
 #include <iostream>
  
 int main()
 {
     using namespace std::complex_literals;
  
     std::complex<double> c = 1.0 + 1i;
     std::cout << "abs" << c << " = " << std::abs(c) << '\\n';
  
     std::complex<float> z = 3.0f + 4.0if;
     std::cout << "abs" << z << " = " << std::abs(z) << '\\n';
 }

.SH Output:

 abs(1,1) = 1.41421
 abs(3,4) = 5

.SH See also

   constructor   constructs a complex number
                 \fI(public member function)\fP 
   operator=     assigns the contents
                 \fI(public member function)\fP 
   C documentation for
   I
