.TH std::vector::reference 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::vector::reference \- std::vector::reference

.SH Synopsis
   class reference;

   The std::vector<bool, Alloc> specializations define std::vector<bool,
   Alloc>::reference as a publicly-accessible nested class. std::vector<bool,
   Alloc>::reference proxies the behavior of references to a single bit in
   std::vector<bool, Alloc>.

   The primary use of std::vector<bool, Alloc>::reference is to provide an lvalue that
   can be returned from operator[].

   Any reads or writes to a vector that happen via a std::vector<bool,
   Alloc>::reference potentially read or write to the entire underlying vector.

.SH Member functions

                 constructs the reference. Accessible only to std::vector<bool, Alloc>
   constructor   itself
                 \fI(public member function)\fP
   destructor    destroys the reference
                 \fI(public member function)\fP
   operator=     assigns a bool to the referenced bit
                 \fI(public member function)\fP
   operator bool returns the referenced bit
                 \fI(public member function)\fP 
   flip          flips the referenced bit
                 \fI(public member function)\fP

std::vector<bool, Alloc>::reference::~reference

   ~reference();            \fI(until C++20)\fP
   constexpr ~reference();  \fI(since C++20)\fP

   Destroys the reference.

std::vector<bool, Alloc>::reference::operator=

   reference& operator=( bool x );                          \fI(until C++11)\fP
   reference& operator=( bool x ) noexcept;                 \fI(since C++11)\fP
                                                            \fI(until C++20)\fP
   constexpr reference& operator=( bool x )                 \fI(since C++20)\fP
   noexcept;
   reference& operator=( const reference& x );      \fB(1)\fP                   \fI(until C++11)\fP
   reference& operator=( const reference& x )                             \fI(since C++11)\fP
   noexcept;                                                              \fI(until C++20)\fP
   constexpr reference& operator=( const reference&     \fB(2)\fP               \fI(since C++20)\fP
   x ) noexcept;
   constexpr const reference& operator=( bool x )           \fB(3)\fP           (since C++23)
   const noexcept;

   Assigns a value to the referenced bit.

.SH Parameters

   x - value to assign

.SH Return value

   *this

std::vector<bool, Alloc>::reference::operator bool

   operator bool() const;                     \fI(until C++11)\fP
   operator bool() const noexcept;            \fI(since C++11)\fP
                                              \fI(until C++20)\fP
   constexpr operator bool() const noexcept;  \fI(since C++20)\fP

   Returns the value of the referenced bit.

.SH Parameters

   \fI(none)\fP

.SH Return value

   The referenced bit.

std::vector<bool, Alloc>::reference::flip

   void flip();                     \fI(until C++11)\fP
   void flip() noexcept;            \fI(since C++11)\fP
                                    \fI(until C++20)\fP
   constexpr void flip() noexcept;  \fI(since C++20)\fP

   Inverts the referenced bit.

.SH Parameters

   \fI(none)\fP

.SH Return value

   \fI(none)\fP

.SH Helper classes

std::formatter<std::vector<bool, Alloc>::reference>

   template < class T, class CharT >

     requires /* is-vector-bool-reference */<T>  (since C++23)

   struct formatter<T, CharT>;

   Specializes the std::formatter for std::vector<bool, Alloc>::reference. The
   specialization uses std::formatter<bool, CharT> as its underlying formatter (denoted
   as underlying_) where the referenced bit is converted to bool to be formatted.

   The exposition-only constant /* is-vector-bool-reference */<T> is true if and only
   if T denotes the type std::vector<bool, Alloc>::reference for some type Alloc and
   std::vector<bool, Alloc> is not a program-defined specialization.

.SH Member functions

   template< class ParseContext >                                     \fB(1)\fP (since C++23)
   constexpr ParseContext::iterator parse( ParseContext& ctx );
   template< class FormatContext >
   FormatContext::iterator format( const T& r, FormatContext& ctx )   \fB(2)\fP (since C++23)
   const;

   1) Equivalent to return underlying_.parse(ctx);.
   2) Equivalent to return underlying_.format(r, ctx);.

.SH Example

    This section is incomplete
    Reason: no example

.SH See also

   operator[] access specified element
              \fI(public member function of std::vector<T,Allocator>)\fP 
   swap       swaps two std::vector<bool>::references
   \fB[static]\fP   \fI(public static member function)\fP 

.SH External links

   "Effective Modern C++" by Scott Meyers (2015), Chapter 2, Item 6: "Use the
   explicitly typed initializer idiom when auto deduces undesired types." (p.43-46) â€”
   describes a possible misuse of the proxy class std::vector<bool>::reference).

.SH Category:
     * Todo no example
