.TH std::pair::pair 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::pair::pair \- std::pair::pair

.SH Synopsis
pair();                             \fI(until C++11)\fP
                                    \fI(since C++11)\fP
constexpr pair();                   (conditionally
                                    explicit)
pair( const T1& x, const                           \fI(until C++11)\fP
T2& y );
                                                   \fI(since C++11)\fP
pair( const T1& x, const                           \fI(until C++14)\fP
T2& y );                                           (conditionally
                                                   explicit)
constexpr pair( const T1&                          \fI(since C++14)\fP
x, const T2& y );                                  (conditionally
                                                   explicit)
template< class U1, class                                         \fI(since C++11)\fP
U2 >                                                              \fI(until C++14)\fP
pair( U1&& x, U2&& y );                                           (conditionally
                                                                  explicit)
template< class U1, class                                         \fI(since C++14)\fP
U2 >                                                              (until C++23)
constexpr pair( U1&& x,                                           (conditionally
U2&& y );                                                         explicit)
template< class U1 = T1,                                          (since C++23)
class U2 = T2 >                                                   (conditionally
constexpr pair( U1&& x,                                           explicit)
U2&& y );
template< class U1, class                                         (since C++23)
U2 >                                               \fB(4)\fP            (conditionally
constexpr pair( pair<U1,                                          explicit)
U2>& p );
template< class U1, class
U2 >                                                                             \fI(until C++11)\fP
pair( const pair<U1, U2>& p
);
template< class U1, class                                                        \fI(since C++11)\fP
U2 >                                                                             \fI(until C++14)\fP
pair( const pair<U1, U2>& p                                                      (conditionally
);                                                                               explicit)
template< class U1, class                                                        \fI(since C++14)\fP
U2 >                                                                             (conditionally
constexpr pair( const                                                            explicit)
pair<U1, U2>& p );          \fB(1)\fP
template< class U1, class                                                                       \fI(since C++11)\fP
U2 >                            \fB(2)\fP                                                             \fI(until C++14)\fP
pair( pair<U1, U2>&& p );                                                                       (conditionally
                                                                                                explicit)
template< class U1, class                                                                       \fI(since C++14)\fP
U2 >                                                                                            (conditionally
constexpr pair( pair<U1,            \fB(3)\fP                                                         explicit)
U2>&& p );
template< class U1, class                                                                       (since C++23)
U2 >                                                                             \fB(7)\fP            (conditionally
constexpr pair( const                                                                           explicit)
pair<U1, U2>&& p );
template< pair-like P >                                                                         (since C++23)
constexpr pair ( P&& u );                                                        \fB(8)\fP            (conditionally
                                                   \fB(5)\fP                                          explicit)
template< class... Args1,
class... Args2 >

pair(                                                                                                          (since
std::piecewise_construct_t,                                                                                    C++11)
      std::tuple<Args1...>                                        \fB(6)\fP                                          (until
first_args,                                                                                                    C++20)

      std::tuple<Args2...>
second_args );
template< class... Args1,
class... Args2 >
                                                                                 \fB(9)\fP
constexpr pair(
std::piecewise_construct_t,
                                                                                                               (since
std::tuple<Args1...>                                                                                           C++20)
first_args,

               
std::tuple<Args2...>
second_args );
pair( const pair& p ) =                                                                         \fB(10)\fP
default;
pair( pair&& p ) = default;                                                                     \fB(11)\fP           (since
                                                                                                               C++11)

   Constructs a new pair.

   1) Default constructor. Value-initializes both elements of the pair, first and
   second.

   This constructor participates in overload resolution if and only if
   std::is_default_constructible_v<T1> and
   std::is_default_constructible_v<T2> are both true.                     \fI(since C++11)\fP

   This constructor is explicit if and only if either T1 or T2 is not
   implicitly default-constructible.

   2) Initializes first with x and second with y.

   This constructor participates in overload resolution if and only if
   std::is_copy_constructible_v<T1> and std::is_copy_constructible_v<T2>
   are both true.
                                                                          \fI(since C++11)\fP
   This constructor is explicit if and only if
   std::is_convertible_v<const T1&, T1> is false or
   std::is_convertible_v<const T2&, T2> is false.

   3) Initializes first with std::forward<U1>(x) and second with std::forward<U2>(y).
   This constructor participates in overload resolution if and only if
   std::is_constructible_v<T1, U1> and std::is_constructible_v<T2, U2> are both true.
   This constructor is explicit if and only if std::is_convertible_v<U1, T1> is false
   or std::is_convertible_v<U2, T2> is false.

   This constructor is defined as deleted if the initialization of first  (since C++23)
   or second would bind a reference to temporary object.

   4) Initializes first with p.first and second with p.second.
   This constructor participates in overload resolution if and only if
   std::is_constructible_v<T1, U1&> and std::is_constructible_v<T2, U2&> are both true.
   This constructor is explicit if and only if std::is_convertible_v<U1&, T1> is false
   or std::is_convertible_v<U2&, T2> is false.
   This constructor is defined as deleted if the initialization of first or second
   would bind a reference to temporary object.
   5) Initializes first with p.first and second with p.second.

   This constructor participates in overload resolution if and only if
   std::is_constructible_v<T1, const U1&> and std::is_constructible_v<T2,
   const U2&> are both true.
                                                                          \fI(since C++11)\fP
   This constructor is explicit if and only if
   std::is_convertible_v<const U1&, T1> is false or
   std::is_convertible_v<const U2&, T2> is false.

   This constructor is defined as deleted if the initialization of first  (since C++23)
   or second would bind a reference to temporary object.

   6) Initializes first with std::forward<U1>(p.first) and second with
   std::forward<U2>(p.second).
   This constructor participates in overload resolution if and only if
   std::is_constructible_v<T1, U1> and std::is_constructible_v<T2, U2> are both true.
   This constructor is explicit if and only if std::is_convertible_v<U1, T1> is false
   or std::is_convertible_v<U2, T2> is false.

   This constructor is defined as deleted if the initialization of first  (since C++23)
   or second would bind a reference to temporary object.

   7) Initializes first with std::forward<const U1>(p.first) and second with
   std::forward<const U2>(p.second).
   This constructor participates in overload resolution if and only if
   std::is_constructible_v<T1, U1> and std::is_constructible_v<T2, U2> are both true.
   This constructor is explicit if and only if std::is_convertible_v<const U1, T1> is
   false or std::is_convertible_v<const U2, T2> is false.
   This constructor is defined as deleted if the initialization of first or second
   would bind a reference to temporary object.
   8) Given u1 as std::get<0>(std::forward(u)) and u2 as std::get<1>(std::forward(u)),
   denote their types as U1 and U2 respectively. Initializes first with u1 and second
   with u2.
   This constructor participates in overload resolution if and only if
     * std::remove_cvref(P) is not a specialization of std::ranges::subrange,
     * std::is_constructible_v<T1, U1> is true, and
     * std::is_constructible_v<T2, U2 is true.
   This constructor is explicit if and only if std::is_convertible_v<U1, T1> is false
   or std::is_convertible_v<U2, T2> is false.
   This constructor is defined as deleted if the initialization of first or second
   would bind a reference to temporary object.
   9) Forwards the elements of first_args to the constructor of first and forwards the
   elements of second_args to the constructor of second. This is the only non-default
   constructor that can be used to create a pair of non-copyable non-movable types. The
   program is ill-formed if first or second is a reference and bound to a temporary
   object.
   10) Copy constructor is
   implicitly declared
   \fI(until C++11)\fP
   defaulted, and is constexpr if copying of both elements satisfies the requirements
   on constexpr functions
   \fI(since C++11)\fP.
   11) Move constructor is defaulted, and is constexpr if moving of both elements
   satisfies the requirements on constexpr functions.

.SH Parameters

   x           - value to initialize the first element of this pair
   y           - value to initialize the second element of this pair
   p           - pair of values used to initialize both elements of this pair
   u           - pair-like object of values used to initialize both elements of this
                 pair
   first_args  - tuple of constructor arguments to initialize the first element of this
                 pair
   second_args - tuple of constructor arguments to initialize the second element of
                 this pair

.SH Exceptions

   Does not throw exceptions unless one of the specified operations (e.g. constructor
   of an element) throws.

.SH Example

   
// Run this code

 #include <complex>
 #include <iostream>
 #include <string>
 #include <tuple>
 #include <utility>
  
 int main()
 {
     auto print = [](auto rem, auto const& pair)
     {
         std::cout << rem << "(" << pair.first << ", " << pair.second << ")\\n";
     };
  
     std::pair<int, float> p1;
     print("(1) Value-initialized: ", p1);
  
     std::pair<int, double> p2{42, 3.1415};
     print("(2) Initialized with two values: ", p2);
  
     std::pair<char, int> p4{p2};
     print("(4) Implicitly converted: ", p4);
  
     std::pair<std::complex<double>, std::string> p6
         {std::piecewise_construct, std::forward_as_tuple(0.123, 7.7),
             std::forward_as_tuple(10, 'a')};
     print("(8) Piecewise constructed: ", p6);
 }

.SH Possible output:

 \fB(1)\fP Value-initialized: (0, 0)
 \fB(2)\fP Initialized with two values: (42, 3.1415)
 \fB(4)\fP Implicitly converted: (*, 3)
 \fB(8)\fP Piecewise constructed: ((0.123,7.7), aaaaaaaaaa)

   Defect reports

   The following behavior-changing defect reports were applied retroactively to
   previously published C++ standards.

      DR    Applied to        Behavior as published              Correct behavior
                       the default constructor
                       copy-initialized first
   LWG 265  C++98      and second with T1() and T2()       first and second
                       respectively                        are value-initialized
                       (thus required T1 and T2 to be
                       CopyConstructible)
   LWG 2510 C++11      the default constructor was         made conditionally-explicit
                       implicit
   N4387    C++11      some constructors were              constructors made
                       implicit-only, preventing some uses conditionally-explicit

.SH See also

   make_pair     creates a pair object of type, defined by the argument types
                 \fI(function template)\fP 
   constructor   constructs a new tuple
                 \fI(public member function of std::tuple<Types...>)\fP 
