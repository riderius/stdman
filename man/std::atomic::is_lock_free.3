.TH std::atomic::is_lock_free 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::atomic::is_lock_free \- std::atomic::is_lock_free

.SH Synopsis
   bool is_lock_free() const noexcept;          \fB(1)\fP \fI(since C++11)\fP
   bool is_lock_free() const volatile noexcept; \fB(2)\fP \fI(since C++11)\fP

   Checks whether the atomic operations on all objects of this type are lock-free.

.SH Parameters

   \fI(none)\fP

.SH Return value

   true if the atomic operations on the objects of this type are lock-free, false
   otherwise.

.SH Notes

   All atomic types except for std::atomic_flag may be implemented using mutexes or
   other locking operations, rather than using the lock-free atomic CPU instructions.
   Atomic types are also allowed to be sometimes lock-free, e.g. if only aligned memory
   accesses are naturally atomic on a given architecture, misaligned objects of the
   same type have to use locks.

   The C++ standard recommends (but does not require) that lock-free atomic operations
   are also address-free, that is, suitable for communication between processes using
   shared memory.

.SH Example

   
// Run this code

 #include <atomic>
 #include <iostream>
 #include <utility>
  
 struct A { int a[100]; };
 struct B { int x, y; };
  
 int main()
 {
     std::cout << std::boolalpha
               << "std::atomic<A> is lock free? "
               << std::atomic<A>{}.is_lock_free() << '\\n'
               << "std::atomic<B> is lock free? "
               << std::atomic<B>{}.is_lock_free() << '\\n';
 }

.SH Possible output:

 std::atomic<A> is lock free? false
 std::atomic<B> is lock free? true

.SH See also

   atomic_is_lock_free                  checks if the atomic type's operations are
   \fI(C++11)\fP                              lock-free
                                        \fI(function template)\fP 
                                        specializes atomic operations for
   atomic_is_lock_free(std::shared_ptr) std::shared_ptr
                                        \fI(function template)\fP
   is_always_lock_free                  indicates that the type is always lock-free
   \fB[static]\fP \fI(C++17)\fP                     \fI(public static member constant)\fP 
