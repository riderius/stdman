.TH std::unordered_map::insert_or_assign 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::unordered_map::insert_or_assign \- std::unordered_map::insert_or_assign

.SH Synopsis
   template< class M >
   std::pair<iterator, bool> insert_or_assign( const Key& k, M&& obj  \fB(1)\fP \fI(since C++17)\fP
   );
   template< class M >                                                \fB(2)\fP \fI(since C++17)\fP
   std::pair<iterator, bool> insert_or_assign( Key&& k, M&& obj );
   template< class K, class M >                                       \fB(3)\fP (since C++26)
   std::pair<iterator, bool> insert_or_assign( K&& k, M&& obj );
   template< class M >
   iterator insert_or_assign( const_iterator hint, const Key& k, M&&  \fB(4)\fP \fI(since C++17)\fP
   obj );
   template< class M >
   iterator insert_or_assign( const_iterator hint, Key&& k, M&& obj   \fB(5)\fP \fI(since C++17)\fP
   );
   template< class K, class M >                                       \fB(6)\fP (since C++26)
   iterator insert_or_assign( const_iterator hint, K&& k, M&& obj );

   1,4) If a key equivalent to k already exists in the container, assigns
   std::forward<M>(obj) to the mapped_type corresponding to the key k. If the key does
   not exist, inserts the new value as if by insert, constructing it from value_type(k,
   std::forward<M>(obj)).
   2,5) Same as (1,4), except the mapped value is constructed from
   value_type(std::move(k), std::forward<M>(obj)).
   3,6) If a key equivalent to k already exists in the container, assigns
   std::forward<M>(obj) to the mapped_type corresponding to the key k. If the key does
   not exist, constructs an object u of value_type with std::forward<K>(k),
   std::forward<M>(obj)), then inserts u into *this. If hash_function()(u.first) !=
   hash_function()(k) || contains(u.first) is true, the behavior is undefined. The
   value_type must be EmplaceConstructible into unordered_map from std::forward<K>(k),
   std::forward<M>(obj). This overload participates in overload resolution only if
   Hash::is_transparent and KeyEqual::is_transparent are valid and each denotes a type.
   This assumes that such Hash is callable with both K and Key type, and that the
   KeyEqual is transparent, which, together, allows calling this function without
   constructing an instance of Key.

   The behavior is undefined
   \fI(until C++20)\fP
   The program is ill-formed
   \fI(since C++20)\fP if std::is_assignable_v<mapped_type&, M&&> is false.

   If after the operation the new number of elements is greater than old
   max_load_factor() * bucket_count() a rehashing takes place.
   If rehashing occurs (due to the insertion), all iterators are invalidated. Otherwise
   (no rehashing), iterators are not invalidated.

.SH Parameters

   k    - the key used both to look up and to insert if not found
   hint - iterator to the position before which the new element will be inserted
   obj  - the value to insert or assign

.SH Return value

   1-3) The bool component is true if the insertion took place and false if the
   assignment took place. The iterator component is pointing at the element that was
   inserted or updated.
   4-6) Iterator pointing at the element that was inserted or updated.

.SH Complexity

   1-3) Same as for emplace.
   4-6) Same as for emplace_hint.

.SH Notes

   insert_or_assign returns more information than operator[] and does not require
   default-constructibility of the mapped type.

             Feature-test macro                Value    Std                 Feature
__cpp_lib_unordered_map_try_emplace           201411L \fI(C++17)\fP std::unordered_map::try_emplace,
                                                              std::unordered_map::insert_or_assign
                                                              Heterogeneous overloads for the
__cpp_lib_associative_heterogeneous_insertion 202311L (C++26) remaining member functions in
                                                              ordered and unordered associative
                                                              containers. Overloads \fB(3)\fP and \fB(6)\fP.

.SH Example

   
// Run this code

 #include <iostream>
 #include <string>
 #include <unordered_map>
  
 void print_node(const auto& node)
 {
     std::cout << '[' << node.first << "] = " << node.second << '\\n';
 }
  
 void print_result(auto const& pair)
 {
     std::cout << (pair.second ? "inserted: " : "assigned: ");
     print_node(*pair.first);
 }
  
 int main()
 {
     std::unordered_map<std::string, std::string> myMap;
  
     print_result(myMap.insert_or_assign("a", "apple"));
     print_result(myMap.insert_or_assign("b", "banana"));
     print_result(myMap.insert_or_assign("c", "cherry"));
     print_result(myMap.insert_or_assign("c", "clementine"));
  
     for (const auto& node : myMap)
         print_node(node);
 }

.SH Possible output:

 inserted: [a] = apple
 inserted: [b] = banana
 inserted: [c] = cherry
 assigned: [c] = clementine
 [c] = clementine
 [a] = apple
 [b] = banana

.SH See also

   operator[] access or insert specified element
              \fI(public member function)\fP 
   at         access specified element with bounds checking
              \fI(public member function)\fP 
              inserts elements
   insert     or nodes
              \fI(since C++17)\fP
              \fI(public member function)\fP 
   emplace    constructs element in-place
              \fI(public member function)\fP 
