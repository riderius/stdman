.TH deductionguidesforstd::function 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
deductionguidesforstd::function \- deductionguidesforstd::function

.SH Synopsis
   Defined in header <functional>
   template< class R, class... ArgTypes >                     \fB(1)\fP \fI(since C++17)\fP
   function( R(*)(ArgTypes...) ) -> function<R(ArgTypes...)>;
   template< class F >                                        \fB(2)\fP \fI(since C++17)\fP
   function( F ) -> function</*see below*/>;
   template< class F >                                        \fB(3)\fP (since C++23)
   function( F ) -> function</*see below*/>;
   template< class F >                                        \fB(4)\fP (since C++23)
   function( F ) -> function</*see below*/>;

   1) This deduction guide is provided for std::function to allow deduction from
   functions.
   2) This overload participates in overload resolution only if &F::operator() is
   well-formed when treated as an unevaluated operand and decltype(&F::operator()) is
   of the form R(G::*)(A...) (optionally cv-qualified, optionally noexcept, optionally
   lvalue reference qualified). The deduced type is std::function<R(A...)>.
   3) This overload participates in overload resolution only if &F::operator() is
   well-formed when treated as an unevaluated operand and F::operator() is an explicit
   object parameter function whose type is of form R(G, A...) or R(G, A...) noexcept.
   The deduced type is std::function<R(A...)>.
   4) This overload participates in overload resolution only if &F::operator() is
   well-formed when treated as an unevaluated operand and F::operator() is a static
   member function whose type is of form R(A...) or R(A...) noexcept. The deduced type
   is std::function<R(A...)>.

.SH Notes

   These deduction guides do not allow deduction from a function with ellipsis
   parameter, and the ... in the types is always treated as a pack expansion.

   The type deduced by these deduction guides may change in a later standard revision
   (in particular, this might happen if noexcept support is added to std::function in a
   later standard).

.SH Example

   
// Run this code

 #include <functional>
 int func(double) { return 0; }
 int main() {
   std::function f{func}; // guide #1 deduces function<int(double)>
   int i = 5;
   std::function g = [&](double) { return i; }; // guide #2 deduces function<int(double)>
 }

   Defect reports

   The following behavior-changing defect reports were applied retroactively to
   previously published C++ standards.

      DR    Applied to     Behavior as published              Correct behavior
                       behavior of (2) was unclear    clarified to be excluded from
   LWG 3238 C++17      when                           overload resolution
                       F::operator() is &&-qualified
