.TH std::shared_ptr::operator*,std::shared_ptr::operator-> 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::shared_ptr::operator*,std::shared_ptr::operator-> \- std::shared_ptr::operator*,std::shared_ptr::operator->

.SH Synopsis
   T& operator*() const noexcept;  \fB(1)\fP \fI(since C++11)\fP
   T* operator->() const noexcept; \fB(2)\fP \fI(since C++11)\fP

   Dereferences the stored pointer. The behavior is undefined if the stored pointer is
   null.

.SH Parameters

   \fI(none)\fP

.SH Return value

   1) The result of dereferencing the stored pointer, i.e., *get().
   2) The stored pointer, i.e., get().

   Remarks

   When T is
   an array type or (possibly cv-qualified)
   \fI(since C++17)\fP void, it is unspecified whether function \fB(1)\fP is declared. If it is
   declared, it is unspecified what its return type is, except that the declaration
   (although not necessarily the definition) of the function shall be well formed. This
   makes it possible to instantiate std::shared_ptr<void>

   When T is an array type, it is unspecified whether function \fB(2)\fP is
   declared. If it is declared, it is unspecified what its return type    \fI(since C++17)\fP
   is, except that the declaration of the function shall be well-formed.

.SH Example

   
// Run this code

 #include <iostream>
 #include <memory>
  
 struct Foo
 {
     Foo(int in) : a(in) {}
     void print() const
     {
         std::cout << "a = " << a << '\\n';
     }
     int a;
 };
  
 int main()
 {
     auto ptr = std::make_shared<Foo>(10);
     ptr->print();
     (*ptr).print();
 }

.SH Output:

 a = 10
 a = 10

.SH See also

   get returns the stored pointer
       \fI(public member function)\fP 
