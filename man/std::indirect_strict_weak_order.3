.TH std::indirect_strict_weak_order 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::indirect_strict_weak_order \- std::indirect_strict_weak_order

.SH Synopsis
   Defined in header <iterator>
   template< class F, class I1, class I2 = I1 >

   concept indirect_strict_weak_order =
       std::indirectly_readable<I1> &&
       std::indirectly_readable<I2> &&
       std::copy_constructible<F> &&
       std::strict_weak_order<F&, std::iter_value_t<I1>&,
   std::iter_value_t<I2>&> &&
       std::strict_weak_order<F&, std::iter_value_t<I1>&,                 \fI(since C++20)\fP
   std::iter_reference_t<I2>> &&
       std::strict_weak_order<F&, std::iter_reference_t<I1>,
   std::iter_value_t<I2>&> &&
       std::strict_weak_order<F&, std::iter_reference_t<I1>,
   std::iter_reference_t<I2>> &&
       std::strict_weak_order<F&, std::iter_common_reference_t<I1>,

                                  std::iter_common_reference_t<I2>>;

   The concept indirect_strict_weak_order specifies requirements for algorithms that
   call strict weak orders as their arguments. The key difference between this concept
   and std::strict_weak_order is that it is applied to the types that I1 and I2
   references, rather than I1 and I2 themselves.

   Semantic requirements

   F, I1, and I2 model indirect_strict_weak_order only if all concepts it subsumes are
   modeled.
