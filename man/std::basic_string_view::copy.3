.TH std::basic_string_view::copy 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::basic_string_view::copy \- std::basic_string_view::copy

.SH Synopsis
   size_type copy( CharT* dest, size_type count, size_type pos  \fI(since C++17)\fP
   = 0 ) const;                                                 (constexpr since C++20)

   Copies the substring [pos, pos + rcount) to the character array pointed to by dest,
   where rcount is the smaller of count and size() - pos.

   Equivalent to Traits::copy(dest, data() + pos, rcount).

.SH Parameters

   dest  - pointer to the destination character string
   count - requested substring length
   pos   - position of the first character

.SH Return value

   Number of characters copied.

.SH Exceptions

   std::out_of_range if pos > size().

.SH Complexity

   Linear in rcount.

.SH Example

   
// Run this code

 #include <array>
 #include <cstddef>
 #include <iostream>
 #include <stdexcept>
 #include <string_view>
  
 int main()
 {
     constexpr std::basic_string_view<char> source{"ABCDEF"};
     std::array<char, 8> dest;
     std::size_t count{}, pos{};
  
     dest.fill('\\0');
     source.copy(dest.data(), count = 4); // pos = 0
     std::cout << dest.data() << '\\n'; // ABCD
  
     dest.fill('\\0');
     source.copy(dest.data(), count = 4, pos = 1);
     std::cout << dest.data() << '\\n'; // BCDE
  
     dest.fill('\\0');
     source.copy(dest.data(), count = 42, pos = 2); // ok, count -> 4
     std::cout << dest.data() << '\\n'; // CDEF
  
     try
     {
         source.copy(dest.data(), count = 1, pos = 666); // throws: pos > size()
     }
     catch (std::out_of_range const& ex)
     {
         std::cout << ex.what() << '\\n';
     }
 }

.SH Output:

 ABCD
 BCDE
 CDEF
 basic_string_view::copy: __pos (which is 666) > __size (which is 6)

.SH See also

   substr  returns a substring
           \fI(public member function)\fP 
   copy    copies characters
           \fI(public member function of std::basic_string<CharT,Traits,Allocator>)\fP 
   copy    copies a range of elements to a new location
   copy_if \fI(function template)\fP 
   \fI(C++11)\fP
   memcpy  copies one buffer to another
           \fI(function)\fP 
