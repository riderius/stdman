.TH std::move_constructible 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::move_constructible \- std::move_constructible

.SH Synopsis
   Defined in header <concepts>
   template< class T >
   concept move_constructible = std::constructible_from<T, T> &&          \fI(since C++20)\fP
   std::convertible_to<T, T>;

   The concept move_constructible is satisfied if T is a reference type, or if it is an
   object type where an object of that type can be constructed from an rvalue of that
   type in both direct- and copy-initialization contexts, with the usual semantics.

   Semantic requirements

   If T is an object type, then move_constructible<T> is modeled only if given

     * rv, an rvalue of type T, and
     * u2, a distinct object of type T equal to rv,

   the following are true:

     * After the definition T u = rv;, u is equal to u2;
     * T(rv) is equal to u2; and
     * If T is not const-qualified, then rv's resulting state (after the
       definition/expression is evaluated in either bullets above) is valid but
       unspecified; otherwise, it is unchanged.

.SH See also

   is_move_constructible
   is_trivially_move_constructible checks if a type can be constructed from an rvalue
   is_nothrow_move_constructible   reference
   \fI(C++11)\fP                         \fI(class template)\fP 
   \fI(C++11)\fP
   \fI(C++11)\fP
