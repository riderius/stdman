.TH std::mem_fn 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::mem_fn \- std::mem_fn

.SH Synopsis
   Defined in header <functional>
   template< class M, class T >                               \fI(since C++11)\fP
   /* unspecified */ mem_fn( M T::* pm ) noexcept;            \fI(until C++20)\fP
   template< class M, class T >                               \fI(since C++20)\fP
   constexpr /* unspecified */ mem_fn( M T::* pm ) noexcept;

   Function template std::mem_fn generates wrapper objects for pointers to members,
   which can store, copy, and invoke a pointer to member. Both references and pointers
   (including smart pointers) to an object can be used when invoking a std::mem_fn.

.SH Parameters

   pm - pointer to member that will be wrapped

.SH Return value

   std::mem_fn returns a call wrapper fn of unspecified type that has the following
   members:

std::mem_fn return type

.SH Member types

   type                                      definition
                                             the return type of pm if pm
   result_type(deprecated in C++17)          is a pointer to member
                                             function, not defined for
                                             pointer to member object
                                             T*, possibly cv-qualified,   \fI(until C++20)\fP
   argument_type(deprecated in C++17)        if pm is a pointer to member
                                             function taking no arguments
                                             T* if pm is a pointer to
   first_argument_type(deprecated in C++17)  member function taking one
                                             argument
                                             T1 if pm is a pointer to
   second_argument_type(deprecated in C++17) member function taking one
                                             argument of type T1

.SH Member function

   template< class... Args >

   /* see below */ operator()(Args&&... args) /* cvref-qualifiers */      \fI(until C++20)\fP

       noexcept(/* see below */);
   template< class... Args >

   constexpr /* see below */ operator()(Args&&... args) /*                \fI(since C++20)\fP
   cvref-qualifiers */

       noexcept(/* see below */);

   The expression fn(args) is equivalent to INVOKE(pmd, args), where pmd is the
   Callable object held by fn, it is of type M T::* and is direct-non-list-initialized
   with pm.

   Thus, the return type of operator() is std::result_of<decltype(pm)(Args&&...)>::type
   or equivalently std::invoke_result_t<decltype(pm), Args&&...>, and the value in
   noexcept specifier is equal to std::is_nothrow_invocable_v<decltype(pm), Args&&...>)
   \fI(since C++17)\fP.

   Each argument in args is perfectly forwarded, as if by std::forward<Args>(args)....

.SH Example

   Use std::mem_fn to store and execute a member function and a member object:

   
// Run this code

 #include <functional>
 #include <iostream>
 #include <memory>
  
 struct Foo
 {
     void display_greeting()
     {
         std::cout << "Hello, world.\\n";
     }
  
     void display_number(int i)
     {
         std::cout << "number: " << i << '\\n';
     }
  
     int add_xy(int x, int y)
     {
         return data + x + y;
     }
  
     template<typename... Args> int add_many(Args... args)
     {
         return data + (args + ...);
     }
  
     auto add_them(auto... args) // C++20 required
     {
         return data + (args + ...);
     }
  
     int data = 7;
 };
  
 int main()
 {
     auto f = Foo{};
  
     auto greet = std::mem_fn(&Foo::display_greeting);
     greet(f);
  
     auto print_num = std::mem_fn(&Foo::display_number);
     print_num(f, 42);
  
     auto access_data = std::mem_fn(&Foo::data);
     std::cout << "data: " << access_data(f) << '\\n';
  
     auto add_xy = std::mem_fn(&Foo::add_xy);
     std::cout << "add_xy: " << add_xy(f, 1, 2) << '\\n';
  
     auto u = std::make_unique<Foo>();
     std::cout << "access_data(u): " << access_data(u) << '\\n';
     std::cout << "add_xy(u, 1, 2): " << add_xy(u, 1, 2) << '\\n';
  
     auto add_many = std::mem_fn(&Foo::add_many<short, int, long>);
     std::cout << "add_many(u, ...): " << add_many(u, 1, 2, 3) << '\\n';
  
     auto add_them = std::mem_fn(&Foo::add_them<short, int, float, double>);
     std::cout << "add_them(u, ...): " << add_them(u, 5, 7, 10.0f, 13.0) << '\\n';
 }

.SH Output:

 Hello, world.
 number: 42
 data: 7
 add_xy: 10
 access_data(u): 7
 add_xy(u, 1, 2): 10
 add_many(u, ...): 13
 add_them(u, ...): 42

   Defect reports

   The following behavior-changing defect reports were applied retroactively to
   previously published C++ standards.

      DR    Applied to     Behavior as published      Correct behavior
   LWG 2048 C++11      unnecessary overloads provided removed
   LWG 2489 C++11      noexcept not required          required

.SH See also

   function           wraps callable object of any copy constructible type with
   \fI(C++11)\fP            specified function call signature
                      \fI(class template)\fP 
   move_only_function wraps callable object of any type with specified function call
   (C++23)            signature
                      \fI(class template)\fP 
   bind               binds one or more arguments to a function object
   \fI(C++11)\fP            \fI(function template)\fP 
