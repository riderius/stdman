.TH std::isgreaterequal 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::isgreaterequal \- std::isgreaterequal

.SH Synopsis
   Defined in header <cmath>
   bool isgreaterequal( float x, float y );
                                                                \fI(since C++11)\fP
   bool isgreaterequal( double x, double y );                   (until C++23)

   bool isgreaterequal( long double x, long double y );
   constexpr bool isgreaterequal( /*
   floating-point-type */ x,                            \fB(1)\fP     (since C++23)
                                  /*
   floating-point-type */ y );
   Additional overloads
   Defined in header <cmath>
   template< class Arithmetic1, class Arithmetic2 >         (A) \fI(since C++11)\fP
   bool isgreaterequal( Arithmetic1 x, Arithmetic2 y );         (constexpr since C++23)

   1) Determines if the floating point number x is greater than or equal to the
   floating-point number y, without setting floating-point exceptions.
   The library provides overloads for all cv-unqualified floating-point types as the
   type of the parameters x and y.
   (since C++23)
   A) Additional overloads are provided for all other combinations of arithmetic types.

.SH Parameters

   x, y - floating-point or integer values

.SH Return value

   true if x >= y, false otherwise.

.SH Notes

   The built-in operator>= for floating-point numbers may raise FE_INVALID if one or
   both of the arguments is NaN. This function is a "quiet" version of operator>=.

   The additional overloads are not required to be provided exactly as (A). They only
   need to be sufficient to ensure that for their first argument num1 and second
   argument num2:

     * If num1 or num2 has type long double, then std::isgreaterequal(num1,
       num2) has the same effect as std::isgreaterequal(static_cast<long
       double>(num1),
                           static_cast<long double>(num2)).
     * Otherwise, if num1 and/or num2 has type double or an integer type, then
       std::isgreaterequal(num1, num2) has the same effect as                    (until
       std::isgreaterequal(static_cast<double>(num1),                            C++23)
                           static_cast<double>(num2)).
     * Otherwise, if num1 or num2 has type float, then std::isgreaterequal(num1,
       num2) has the same effect as
       std::isgreaterequal(static_cast<float>(num1),
                           static_cast<float>(num2)).
   If num1 and num2 have arithmetic types, then std::isgreaterequal(num1, num2)
   has the same effect as std::isgreaterequal(static_cast</*
   common-floating-point-type */>(num1),
                       static_cast</* common-floating-point-type */>(num2)),
   where /* common-floating-point-type */ is the floating-point type with the
   greatest floating-point conversion rank and greatest floating-point           (since
   conversion subrank between the types of num1 and num2, arguments of integer   C++23)
   type are considered to have the same floating-point conversion rank as
   double.

   If no such floating-point type with the greatest rank and subrank exists,
   then overload resolution does not result in a usable candidate from the
   overloads provided.

.SH See also

   greater_equal function object implementing x >= y
                 \fI(class template)\fP 
   islessequal   checks if the first floating-point argument is less or equal than the
   \fI(C++11)\fP       second
                 \fI(function)\fP 
   C documentation for
   isgreaterequal
