.TH std::ranges::subrange::next 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::ranges::subrange::next \- std::ranges::subrange::next

.SH Synopsis
   [[nodiscard]] constexpr subrange next(std::iter_difference_t<I> n
   = 1) const&                                                        \fB(1)\fP \fI(since C++20)\fP
       requires std::forward_iterator<I>;
   [[nodiscard]] constexpr subrange next(std::iter_difference_t<I> n  \fB(2)\fP \fI(since C++20)\fP
   = 1) &&;

   1) Obtains a subrange whose iterator is incremented by min(n, size()) times or
   decremented by -n times respect to that of *this, when n >= 0 or n < 0 respectively.
   Equivalent to auto tmp = *this; tmp.advance(n); return tmp;.
   2) Increments the stored iterator by min(n, size()) times or decremented it by -n
   times, when n >= 0 or n < 0 respectively, and then move-constructs the result from
   *this. Equivalent to advance(n); return std::move(*this);.

   The behavior is undefined if:

     * I does not model bidirectional_iterator and n < 0, or
     * the stored iterator is decremented after becoming a non-decrementable value.

.SH Return value

   A subrange whose iterator is incremented by min(n, size()) times or decremented by
   -n times respect to the original value of that of *this, when n >= 0 or n < 0
   respectively.

.SH Complexity

   Generally min(n, size()) increments or -n decrements on the iterator, when n >= 0 or
   n < 0 respectively.

   Constant if I models random_access_iterator, and either n < 0 or
   std::sized_sentinel_for<S, I> is modeled.

.SH Notes

   A call to \fB(2)\fP may leave *this in a valid but unspecified state, depending on the
   behavior of the move constructor of I and S.

.SH Example

    This section is incomplete
    Reason: no example

.SH See also

   prev         obtains a copy of the subrange with its iterator decremented by a given
   (C++20)      distance
                \fI(public member function)\fP 
   advance      advances the iterator by given distance
   (C++20)      \fI(public member function)\fP 
   next         increment an iterator
   \fI(C++11)\fP      \fI(function template)\fP 
   ranges::next increment an iterator by a given distance or to a bound
   (C++20)      (niebloid)

.SH Category:
     * Todo no example
