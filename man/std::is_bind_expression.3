.TH std::is_bind_expression 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::is_bind_expression \- std::is_bind_expression

.SH Synopsis
   Defined in header <functional>
   template< class T >             \fI(since C++11)\fP
   struct is_bind_expression;

   If T is a type produced by a call to std::bind (but not std::bind_front or
   std::bind_back), this template is derived from std::true_type. For any other type
   (unless user-specialized), this template is derived from std::false_type.

   A program may specialize this template for a program-defined type T to implement
   UnaryTypeTrait with base characteristic of std::true_type to indicate that T should
   be treated by std::bind as if it were the type of a bind subexpression: when a
   bind-generated function object is invoked, a bound argument of this type will be
   invoked as a function object and will be given all the unbound arguments passed to
   the bind-generated object.

.SH Member constants

   value    true if T is a function object generated by std::bind, false otherwise
   \fB[static]\fP \fI(public static member constant)\fP

.SH Member functions

   operator bool converts the object to bool, returns value
                 \fI(public member function)\fP
   operator()    returns value
   \fI(C++14)\fP       \fI(public member function)\fP

.SH Member types

   Type       Definition
   value_type bool
   type       std::integral_constant<bool, value>

.SH Example

   
// Run this code

 #include <functional>
 #include <iostream>
 #include <type_traits>
  
 struct MyBind
 {
     typedef int result_type;
     int operator()(int a, int b) const { return a + b; }
 };
  
 namespace std
 {
     template<>
     struct is_bind_expression<MyBind> : public true_type {};
 }
  
 int f(int n1, int n2)
 {
     return n1 + n2;
 }
  
 int main()
 {
     // as if bind(f, bind(MyBind(), _1, _2), 2)
     auto b = std::bind(f, MyBind(), 2);
  
     std::cout << "Adding 2 to the sum of 10 and 11 gives " << b(10, 11) << '\\n';
 }

.SH Output:

 Adding 2 to the sum of 10 and 11 gives 23

   Defect reports

   The following behavior-changing defect reports were applied retroactively to
   previously published C++ standards.

      DR    Applied to         Behavior as published          Correct behavior
   LWG 2010 C++11      program-defined specializations could can be derived from
                       only be derived from std::false_type  std::true_type

.SH See also

   bind    binds one or more arguments to a function object
   \fI(C++11)\fP \fI(function template)\fP 
