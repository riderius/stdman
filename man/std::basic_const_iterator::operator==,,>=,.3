.TH std::basic_const_iterator::operator==,,>=, 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::basic_const_iterator::operator==,,>=, \- std::basic_const_iterator::operator==,,>=,

.SH Synopsis
   Equality comparison
   template< std::sentinel_for<Iter> S >                             \fB(1)\fP  (since C++23)
   constexpr bool operator==( const S& s ) const;
   Relational comparisons between two basic_const_iterators
   constexpr bool operator<( const basic_const_iterator& y ) const   \fB(2)\fP  (since C++23)
       requires std::random_access_iterator<Iter>;
   constexpr bool operator>( const basic_const_iterator& y ) const   \fB(3)\fP  (since C++23)
       requires std::random_access_iterator<Iter>;
   constexpr bool operator<=( const basic_const_iterator& y ) const  \fB(4)\fP  (since C++23)
       requires std::random_access_iterator<Iter>;
   constexpr bool operator>=( const basic_const_iterator& y ) const  \fB(5)\fP  (since C++23)
       requires std::random_access_iterator<Iter>;
   constexpr auto operator<=>( const basic_const_iterator& y ) const
       requires std::random_access_iterator<Iter> &&                 \fB(6)\fP  (since C++23)
   std::three_way_comparable<Iter>;
   Relational comparisons between basic_const_iterator and another
   type
   template< /*different-from*/<basic_const_iterator> I >

   constexpr bool operator<( const I& y ) const                      \fB(7)\fP  (since C++23)

       requires std::random_access_iterator<Iter> &&
   std::totally_ordered_with<Iter, I>;
   template< /*different-from*/<basic_const_iterator> I >

   constexpr bool operator>( const I& y ) const                      \fB(8)\fP  (since C++23)

       requires std::random_access_iterator<Iter> &&
   std::totally_ordered_with<Iter, I>;
   template< /*different-from*/<basic_const_iterator> I >

   constexpr bool operator<=( const I& y ) const                     \fB(9)\fP  (since C++23)

       requires std::random_access_iterator<Iter> &&
   std::totally_ordered_with<Iter, I>;
   template< /*different-from*/<basic_const_iterator> I >

   constexpr bool operator>=( const I& y ) const                     \fB(10)\fP (since C++23)

       requires std::random_access_iterator<Iter> &&
   std::totally_ordered_with<Iter, I>;
   template< /*different-from*/<basic_const_iterator> I >

   constexpr auto operator<=>( const I& y ) const
       requires std::random_access_iterator<Iter> &&                 \fB(11)\fP (since C++23)
           std::totally_ordered_with<Iter, I> &&

           std::three_way_comparable_with<Iter, I>;

   Compares a basic_const_iterator with another value.

   The != operator is synthesized from operator==.

   I satisfies /*different-from*/<basic_const_iterator> if std::same_as<I,
   basic_const_iterator<Iter>> is false.

.SH Parameters

   s - a sentinel for Iter
   y - a value to compare with

.SH Return value

   1) base() == s
   2) base() < y.base()
   3) base() > y.base()
   4) base() <= y.base()
   5) base() >= y.base()
   6) base() <=> y.base()
   7) base() < y
   8) base() > y
   9) base() <= y
   10) base() >= y
   11) base() <=> y

.SH Notes

   Overload \fB(1)\fP can be used to compare two basic_const_iterator<Iter> values if Iter
   models sentinel_for<Iter>.

.SH Example

    This section is incomplete
    Reason: no example

.SH See also

    This section is incomplete

.SH Categories:
     * Todo no example
     * Todo without reason
