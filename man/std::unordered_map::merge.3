.TH std::unordered_map::merge 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::unordered_map::merge \- std::unordered_map::merge

.SH Synopsis
   template< class H2, class P2 >
   void merge( std::unordered_map<Key, T, H2, P2, Allocator>& source  \fB(1)\fP \fI(since C++17)\fP
   );
   template< class H2, class P2 >
   void merge( std::unordered_map<Key, T, H2, P2, Allocator>&& source \fB(2)\fP \fI(since C++17)\fP
   );
   template< class H2, class P2 >
   void merge( std::unordered_multimap<Key, T, H2, P2, Allocator>&    \fB(3)\fP \fI(since C++17)\fP
   source );
   template< class H2, class P2 >
   void merge( std::unordered_multimap<Key, T, H2, P2, Allocator>&&   \fB(4)\fP \fI(since C++17)\fP
   source );

   Attempts to extract ("splice") each element in source and insert it into *this using
   the hash function and key equality predicate of *this. If there is an element in
   *this with key equivalent to the key of an element from source, then that element is
   not extracted from source. No elements are copied or moved, only the internal
   pointers of the container nodes are repointed. All pointers and references to the
   transferred elements remain valid, but now refer into *this, not into source.
   Iterators referring to the transferred elements and all iterators referring to *this
   are invalidated. Iterators to elements remaining in source remain valid.

   The behavior is undefined if get_allocator() != source.get_allocator().

.SH Parameters

   source - compatible container to transfer the nodes from

.SH Return value

   \fI(none)\fP

.SH Complexity

   Average case O(N), worst case O(N * size() + N), where N is source.size().

.SH Example

   
// Run this code

 #include <iostream>
 #include <string>
 #include <unordered_map>
 #include <utility>
  
 // print out a std::pair
 template<class Os, class U, class V>
 Os& operator<<(Os& os, const std::pair<U,V>& p)
 {
     return os << '{' << p.first << ", " << p.second << '}';
 }
  
 // print out an associative container
 template<class Os, class K, class V>
 Os& operator<<(Os& os, const std::unordered_map<K, V>& v)
 {
     os << '[' << v.size() << "] {";
     bool o{};
     for (const auto& e : v)
         os << (o ? ", " : (o = 1, "")) << e;
     return os << "}\\n";
 }
  
 int main()
 {
     std::unordered_map<std::string, int>
         p{{"C", 3}, {"B", 2}, {"A", 1}, {"A", 0}},
         q{{"E", 6}, {"E", 7}, {"D", 5}, {"A", 4}};
  
     std::cout << "p: " << p << "q: " << q;
  
     p.merge(q);
  
     std::cout << "p.merge(q);\\n" << "p: " << p << "q: " << q;
 }

.SH Possible output:

 p: [3] {{A, 1}, {B, 2}, {C, 3}}
 q: [3] {{A, 4}, {D, 5}, {E, 6}}
 p.merge(q);
 p: [5] {{E, 6}, {D, 5}, {A, 1}, {B, 2}, {C, 3}}
 q: [1] {{A, 4}}

.SH See also

   extract extracts nodes from the container
   \fI(C++17)\fP \fI(public member function)\fP 
           inserts elements
   insert  or nodes
           \fI(since C++17)\fP
           \fI(public member function)\fP 
