.TH std::get(std::pair) 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::get(std::pair) \- std::get(std::pair)

.SH Synopsis
   Defined in header <utility>
   template< std::size_t I, class T1, class T2 >

   typename std::tuple_element<I, std::pair<T1,T2>         \fB(1)\fP  \fI(since C++11)\fP
   >::type&                                                     (constexpr since C++14)

       get( std::pair<T1, T2>& p ) noexcept;
   template< std::size_t I, class T1, class T2 >

   const typename std::tuple_element<I, std::pair<T1,T2>   \fB(2)\fP  \fI(since C++11)\fP
   >::type&                                                     (constexpr since C++14)

       get( const std::pair<T1,T2>& p ) noexcept;
   template< std::size_t I, class T1, class T2 >

   typename std::tuple_element<I, std::pair<T1,T2>         \fB(3)\fP  \fI(since C++11)\fP
   >::type&&                                                    (constexpr since C++14)

       get( std::pair<T1,T2>&& p ) noexcept;
   template< std::size_t I, class T1, class T2 >

   const typename std::tuple_element<I, std::pair<T1,T2>   \fB(4)\fP  \fI(since C++11)\fP
   >::type&&                                                    (constexpr since C++14)

       get( const std::pair<T1,T2>&& p ) noexcept;
   template< class T, class U >                            \fB(5)\fP  \fI(since C++14)\fP
   constexpr T& get( std::pair<T, U>& p ) noexcept;
   template< class T, class U >
   constexpr const T& get( const std::pair<T, U>& p )      \fB(6)\fP  \fI(since C++14)\fP
   noexcept;
   template< class T, class U >                            \fB(7)\fP  \fI(since C++14)\fP
   constexpr T&& get( std::pair<T, U>&& p ) noexcept;
   template< class T, class U >
   constexpr const T&& get( const std::pair<T, U>&& p )    \fB(8)\fP  \fI(since C++14)\fP
   noexcept;
   template< class T, class U >                            \fB(9)\fP  \fI(since C++14)\fP
   constexpr T& get( std::pair<U, T>& p ) noexcept;
   template< class T, class U >
   constexpr const T& get( const std::pair<U, T>& p )      \fB(10)\fP \fI(since C++14)\fP
   noexcept;
   template< class T, class U >                            \fB(11)\fP \fI(since C++14)\fP
   constexpr T&& get( std::pair<U, T>&& p ) noexcept;
   template< class T, class U >
   constexpr const T&& get( const std::pair<U, T>&& p )    \fB(12)\fP \fI(since C++14)\fP
   noexcept;

   Extracts an element from the pair using tuple-like interface.

   1-4) The index-based overloads fail to compile if the index I is neither 0 nor 1.
   5-12) The type-based overloads fail to compile if the types T and U are the same.

.SH Parameters

   p - pair whose contents to extract

.SH Return value

   1-4) Returns a reference to p.first if I == 0 and a reference to p.second if I == 1.
   5-8) Returns a reference to p.first.
   9-12) Returns a reference to p.second.

.SH Example

   
// Run this code

 #include <iostream>
 #include <utility>
  
 int main()
 {
     auto p = std::make_pair(1, 3.14);
     std::cout << '(' << std::get<0>(p) << ", " << std::get<1>(p) << ")\\n";
     std::cout << '(' << std::get<int>(p) << ", " << std::get<double>(p) << ")\\n";
 }

.SH Output:

 (1, 3.14)
 (1, 3.14)

   Defect reports

   The following behavior-changing defect reports were applied retroactively to
   previously published C++ standards.

      DR       Applied to          Behavior as published           Correct behavior
   LWG 2485 C++11 (by index) there are no overloads for const   the overloads are added
            C++14 (by type)  pair&&

.SH See also

   Structured binding \fI(C++17)\fP binds the specified names to sub-objects or tuple
                              elements of the initializer
   get(std::tuple)            tuple accesses specified element
   \fI(C++11)\fP                    \fI(function template)\fP 
   get(std::array)            accesses an element of an array
   \fI(C++11)\fP                    \fI(function template)\fP 
   get(std::variant)          reads the value of the variant given the index or the
   \fI(C++17)\fP                    type (if the type is unique), throws on error
                              \fI(function template)\fP 
   get(std::ranges::subrange) obtains iterator or sentinel from a std::ranges::subrange
   (C++20)                    \fI(function template)\fP 
