.TH std::isless 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::isless \- std::isless

.SH Synopsis
   Defined in header <cmath>
   bool isless( float x, float y );
                                                                \fI(since C++11)\fP
   bool isless( double x, double y );                           (until C++23)

   bool isless( long double x, long double y );
   constexpr bool isless( /* floating-point-type */ x,  \fB(1)\fP
                          /* floating-point-type */ y           (since C++23)
   );
   Additional overloads
   Defined in header <cmath>
   template< class Arithmetic1, class Arithmetic2 >         (A) \fI(since C++11)\fP
   bool isless( Arithmetic1 x, Arithmetic2 y );                 (constexpr since C++23)

   1) Determines if the floating point number x is less than the floating-point number
   y, without setting floating-point exceptions.
   The library provides overloads for all cv-unqualified floating-point types as the
   type of the parameters x and y.
   (since C++23)
   A) Additional overloads are provided for all other combinations of arithmetic types.

.SH Parameters

   x, y - floating-point or integer values

.SH Return value

   true if x < y, false otherwise.

.SH Notes

   The built-in operator< for floating-point numbers may raise FE_INVALID if one or
   both of the arguments is NaN. This function is a "quiet" version of operator<.

   The additional overloads are not required to be provided exactly as (A). They only
   need to be sufficient to ensure that for their first argument num1 and second
   argument num2:

     * If num1 or num2 has type long double, then std::isless(num1, num2)
       has the same effect as std::isless(static_cast<long double>(num1),
                   static_cast<long double>(num2)).
     * Otherwise, if num1 and/or num2 has type double or an integer type,
       then std::isless(num1, num2) has the same effect as                (until C++23)
       std::isless(static_cast<double>(num1),
                   static_cast<double>(num2)).
     * Otherwise, if num1 or num2 has type float, then std::isless(num1,
       num2) has the same effect as std::isless(static_cast<float>(num1),
                   static_cast<float>(num2)).
   If num1 and num2 have arithmetic types, then std::isless(num1, num2)
   has the same effect as std::isless(static_cast</*
   common-floating-point-type */>(num1),
               static_cast</* common-floating-point-type */>(num2)),
   where /* common-floating-point-type */ is the floating-point type with
   the greatest floating-point conversion rank and greatest
   floating-point conversion subrank between the types of num1 and num2,  (since C++23)
   arguments of integer type are considered to have the same
   floating-point conversion rank as double.

   If no such floating-point type with the greatest rank and subrank
   exists, then overload resolution does not result in a usable candidate
   from the overloads provided.

.SH See also

   less      function object implementing x < y
             \fI(class template)\fP 
   isgreater checks if the first floating-point argument is greater than the second
   \fI(C++11)\fP   \fI(function)\fP 
   C documentation for
   isless
