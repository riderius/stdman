.TH std::numeric_limits::is_signed 3 "2024.06.10" "http://cppreference.com" "C++ Standard Libary"
.SH NAME
std::numeric_limits::is_signed \- std::numeric_limits::is_signed

.SH Synopsis
   static const bool is_signed;      \fI(until C++11)\fP
   static constexpr bool is_signed;  \fI(since C++11)\fP

   The value of std::numeric_limits<T>::is_signed is true for all signed arithmetic
   types T and false for the unsigned types. This constant is meaningful for all
   specializations.

.SH Standard specializations

   T                                value of std::numeric_limits<T>::is_signed
   /* non-specialized */            false
   bool                             false
   char                             implementation-defined
   signed char                      true
   unsigned char                    false
   wchar_t                          implementation-defined
   char8_t \fI(since C++20)\fP            false
   char16_t \fI(since C++11)\fP           false
   char32_t \fI(since C++11)\fP           false
   short                            true
   unsigned short                   false
   int                              true
   unsigned int                     false
   long                             true
   unsigned long                    false
   long long \fI(since C++11)\fP          true
   unsigned long long \fI(since C++11)\fP false
   float                            true
   double                           true
   long double                      true

.SH Example

   
// Run this code

 #include <iostream>
 #include <iomanip>
 #include <limits>
  
 template<typename T>
 struct test
 {
     test(const char* name, int w = 15)
     {
         std::cout
             << std::left << std::setw(w)
             << (std::numeric_limits<T>::is_specialized ? name : "non-specialized")
             << " : "
             << (std::numeric_limits<T>::is_signed ? "" : "un") << "signed\\n";
     }
 };
  
 int main()
 {
     test<bool>{"bool"};
     test<char>{"char"};
     test<wchar_t>{"wchar_t"};
     test<char16_t>{"char16_t"};
     test<char32_t>{"char32_t"};
     test<float>{"float"};
     struct delusion{};
     test<delusion>{"delusion"};
     test<decltype(42)>{"decltype(42)"};
 }

.SH Possible output:

 bool            : unsigned
 char            : signed
 wchar_t         : signed
 char16_t        : unsigned
 char32_t        : unsigned
 float           : signed
 non-specialized : unsigned
 decltype\fB(42)\fP    : signed

.SH See also

   is_signed  checks if a type is a signed arithmetic type
   \fI(C++11)\fP    \fI(class template)\fP 
   is_integer identifies integer types
   \fB[static]\fP   \fI(public static member constant)\fP 
   is_exact   identifies exact types
   \fB[static]\fP   \fI(public static member constant)\fP 
   is_bounded identifies types that represent a finite set of values
   \fB[static]\fP   \fI(public static member constant)\fP 
